- Собственные созданные страницы-Классы необходимо унаследовать его от ContentPage.
- Для загрузки своей страницы в "App.xaml.cs" прописать вместо 
```C#
public App()
{
    // инициализация интерфейса
    InitializeComponent();
    // Инициализация главного экрана
    MainPage = new MainPage();
}
```
вот это:
```C#
public App()
{
    // инициализация интерфейса
    InitializeComponent();
    // Инициализация главного экрана
    MainPage = new myLoadingPage();
}
```
- Для того, чтобы можно было переключаться между страницами нужно прописать:
```C#
MainPage = new NavigationPage(new НужнаяСтраница());
```
-  Для того, чтобы вести зависимость от запущенной платформы:
```C#
// Изменяем внешний вид кнопки для Windows-версии
   if (Device.RuntimePlatform == Device.[название платформы])
   {
   }
```

- Если не нравится черная полоса, которая по умолчанию рендерится под каждым из окошек текстового ввода как в <Entry> или <Editor>, то можно изменить это поведение,
  добавив в сборку под Android свои кастомные классы для переопределения рендеринга (классы CustomEditorRenderer.cs - убирает полосу под текстом в теге <Editor> и
  CustomEntryRenderer.cs- убирает полосу под текстом в теге <Entry> )! 

- Для использования изображениня в проекте на Android добавить его в соответствующую сборку, и поместим в каталог [имя проекта].Android → Resources → drawable.
    Для UWP проще всего — изображение можно просто положить в корневую папку проекта, При этом не забудьте проставить в Properties этот флаг: build action - "Content"; 
    К примеру, если мы переименуем HomeBackgroung.jpg в HomeBackground.scale-200.jpg, то это будет означать, что файл следует масштабировать на 200%(это касается платформы UWP). 

App.xaml — определяет общие ресурсы, доступные для всего приложения.
App.xaml.cs — входная точка нашего приложения, этот код выполняется при запуске.
MainPage.xaml — здесь с помощью языка XAML описан UI (пользовательский интерфейс) для единственной на данный момент в проекте страницы MainPage.
MainPage.xaml.cs — здесь расположена С#-логика страницы MainPage.
AssemblyInfo.cs — файл содержит С#-код, устанавливающий настройки и конфигурацию приложения.

# DependencyService 
позволяет вызывать из общей сборки различный платформо-зависимый код, «спрятанный» внутри реализации конкретной платформы 

# отладка через USB
Отладка по USB доступна в Android-устройствах только в режиме разработчика. Чтобы его включить, выбираем Настройки → О телефоне, далее нажимаем на пункт Номер сборки последовательно несколько раз, пока не увидите уведомление «Вы стали разработчиком».
Снова заходим в меню, выбираем Режим разработчика и включаем отладку по USB.
Подключите свой телефон к ПК по USB. Обратите внимание, что может потребоваться напрямую подключить его к USB-порту, расположенному на материнской плате, так как при подключении через различные удлинители или хабы ваше устройство может не обнаруживаться.
Теперь на телефоне вы должны получить уведомление «Доверять ли этому ПК?» Подтверждаем, выбираем «Да».
Теперь запускаем Visual Studio. Если она у вас была запущена до этого — перезапустите.
Откройте ещё раз проект HomeApp, в выпадающем списке доступных для отладки устройств вы должны увидеть свой смартфон: 

# Использование триггеров
см. созданный класс "EmailTriggerAction.cs"  и страницу "myRegistrationPage"

# Использование CSS 
см. созданную папку "Static" и "DevicesPage.xaml".
Разберём, что у нас тут есть:
        - Наш CSS-стиль подключен внутри тегов <ContentPage.Resources></ContentPage.Resources>.
        - Для текстового поля Label установлено свойство StyleId, чтобы из нашего стиля мы могли к нему применить селектор по идентификатору.
        - Для кнопки Button установлено свойство StyleClass, для того чтобы мы могли к нему применить селектор по классу.
# Visual State Manager - визуальные состояния элемента
см. "myDeviceContolPage.cs" и "myDeviceContolPage.xaml.cs".
По умолчанию Visual State Manager позволяет элементам использовать группу из трёх состояний:
        - Disabled — элемент выключен и недоступен для использования.
        - Focused — пользователь взял элемент в фокус (к примеру, тапнул и выбрал), элемент используется в текущий момент времени.
        - Normal — обычное состояние элемента.
# Свои состояния
см."NewDevicePage.xaml" и "NewDevicePage.xaml.cs", а также "App.xaml".
Чтобы реализовать свое состояние, нам необходимо сперва разобраться в том, как работают встроенные состояния.
Происходит отслеживание изменений. К примеру, для перехода в состояние Focused или Disabled должен произойти следующий вызов:
        - VisualStateManager.GoToState(element, "Focused"). Метод соответственно принимает два аргумента: элемент, для которого устанавливается состояние, и значение этого состояния.
Элемент при этом должен наследоваться от VisualElement.

# Binding 

## привязка из одного источника 
см. "myBindigPage.xaml.cs" и "myBindigPage.xaml".
## 
см. "BindingModePage.xaml.cs" и "BindingModePage.xaml".
Один визуальный компонент может иметь привязку данных для нескольких свойств.
Однако у одного компонента может быть только один BindingContext, поэтому множественные привязки данных этого компонента должны все ссылаться на свойства одного этого объекта.
Эта проблема решается с помощью свойства BindingMode, имеющего следующие значения:
    - Default — режим привязки по умолчанию.
    - OneWay — только целевой объект получает изменения значений источника.
    - OneWayToSource — значения передаются из целевого объекта в источник. 
    - TwoWay — двусторонняя передача значений.
    - OneTime — цель получает изменения от источника, но только когда изменяется BindingContext.
# Простой ListView
В разработке на Xamarin довольно часто используется комбинированный вариант, при котором источник данных ListView определен в коде C#, а разметка страницы — в XAML,
и в этом случае мы должны будем использовать привязку данных.
см. "myDeviceListPage".

# Выбор элементов ItemTapped, ItemSelected
Повторное нажатие на один и тот же элемент вызовет ItemTapped, но не вызовет ItemSelected, по понятной причине (элемент ведь уже был выбран, произошло лишь повторное нажатие). Таким
образом, ItemTapped будет срабатывать каждый раз при нажатии. Ещё момент: ItemSelected сработает также при снятии выделения с элемента.

# ListView и сложные модели. DataTemplate
см."HomeDevice.cs" и "DeviceListPage". 
В нашем примере нам потребовалось вывести на экран список, состоящий из устройств и кратких описаний (аннотаций) к ним. Для этого внутри ListView мы использовали объект ViewCell.
ViewCell представляет собой ячейку-хранилище для самых различных произвольных элементов по нашему усмотрению.
1. ViewCell — это тип ячейки с данными, и она может использоваться внутри представления ListView, как в примере выше.
2. Табличное представление TableView также может содержать ячейки типа ViewCell.
4. В этом и состоит его назначение — он может содержать любой набор элементов и следовательно принимать почти любой вид. Также мы можем создать специализированный свой текст
    ячейки, унаследовав его от ViewCell.

# TextCell
см."HomeDevice.cs" и "DeviceListPage". TЕсли на первом месте возможность полной кастомизации внешнего вида интерфейса, возможно, стоит сделать выбор в пользу ViewCell.
# ImageCell
см."HomeDevice.cs" и "DeviceListPage" - см. <!--подключене изображений-->

# ObservableCollection
см."HomeDevice.cs" и "DeviceListPage" - см. <!--ObservableCollection-->

# Группировка в ListView
Для создания группировки нам потребуется специальный класс, представляющий группируемую коллекцию Group.cs
см."Group.cs" и ""
Xamarin.Forms предоставляет для ListView различные конфигурации кеширования, описываемые ListViewCachingStrategy. Поддерживается установка RetainElement (стоит по умолчанию, предполагает создание ячейки для каждого элемента в списке) или RecycleElement (переиспользование одних и тех же ячеек элементов).

Когда использовать RetainElement?

        Если каждая ячейка ListView имеет много привязок. Например, более 20.
        Если нам надо часто менять шаблон ячейки.

Когда использовать ReсycleElement?

        Если количество привязок ячейки невелико.
        Все данные ячейки определяются свойством BindingContext.
        Все ячейки ListView в целом аналогичны, и их шаблон неизменен.

# Базовая навигация
см. "App.xaml" и "myLoginPage", "DeviceListPage.xaml" и "HomeDevice"(добавлен INotifyPropertyChanged)
У каждой из страниц Page нашего приложения предусмотрено свойство Navigation.

### Переходы вперёд
Для перехода на следующую страницу вместо Page будем передавать ту страницу, на которую требуется перейти. К примеру, если хотим с LoginPage перейти на DevicesPage, в LoginPage вызываем Navigation.PushAsync(new DevicesPage).

### Переходы назад
Для возврата на предыдущую страницу существуют методы Task PopAsync() и Task PopModalAsync() соответственно.

# Передача данных между страницами 
(см. "myDeviceListPage.xaml" и "DeviceListPage.xaml.cs" и "myNewDevicePage")

1. Через метод-конструктор
То есть в классе PageOne надо будет предусмотреть метод-конструктор, принимающий нужное количество аргументов, после чего организовать переход на страницу из класса PageOne можно будет, например, так:
```C# await Navigation.PushAsync(new PageTwo("Расписание на месяц"));```
Этот способ самый простой и самый распространенный.

2. Через методы или свойства страницы
В этом случае в коде PageOne создаем страницу PageTwo, вызываем напрямую соответствующие методы или инициализируем свойства PageTwo, после чего запускаем навигацию, например так:
```C#
var pageTwo = new PageTwo();
pageTwo.StudentProfileName = "Андрей";
pageTwo.AddStudentProfileBio("Студент третьего курса");
await Navigation.PushAsync(pageTwo);
```
# способы постоянного хранения данных в приложении Xamarin.Forms:

        -- Файлы в файловой системе мобильного устройства.
        -- Локальная (SQL-подобная или другая) база данных на мобильном устройстве.
        -- Класс Preferences из пространства имен Xamarin.Essentials, который предоставляет доступ к свойствам и настройкам нативной платформы, на которой запущено приложение.
            Этот способ не подходит для хранения комплексных данных, использовать следует только для фрагментарных данных простого типа. 
        -- Встроенное хранилище приложения — коллекция Properties в классе Application (предназначена для хранения временных данных приложения).

Все эти способы позволяют сохранять данные при перезапуске приложения.
## Properties (что-то типа Dictionary - есть "ключ" и "значение")
см. "DeviceListPage.xaml" "UserInfo.cs". В "ProfilePage" его применение.
 
    - Данное свойство расположено в классе Application, и представляет из себя словарь, где можно для каждого строкового ключа сохранить некоторое нужное значение.
    - Позволяет хранение комплексных данных
    - Предполагает прямое извлечение значений по ключу без использования доп.методов
    - данные при перезапуске сохраняются
 
## Preferences (using Xamarin.Essentials;)
см "ProfilePage.xaml.cs"

    - данные при перезапуске сохраняются
    
Позволяет хранить небольшие фрагменты данных, используя встроенный контейнер нативной платформы.
ряд основных методов:

        -- void Set (k, v) — для сохранения значения по ключу;
        -- string Get (key, ...) — получение значения по ключу, если значение отсутствует, то вернется значение по умолчанию;
        -- void Remove(key) — удаление значения по ключу;
        -- void Clear() — полная очистка настроек;
        -- bool ContainsKey(key) — проверяет, есть ли такая настройка в словаре.

## сохраниение в файлах
см. "HomeDevice", "DeviceListPage"
Для работы с файловой системой будут использоваться Directory и DirectoryInfo, для файлов — File и FileInfo.
## сохранение в БД
см."HomeApp/Data/Tables/HomeDevice.cs" (для принципа единства ответственности), "HomeDeviceRepository", "App.xaml.cs"

    - В качестве компактной мобильной БД используется SQLite, и для работы с ней установите NuGet-пакет sqlite-net-pcl (в командной строке: dotnet add package sqlite-net-pcl --version 1.8.116).
    - Также для удобного и компактного преобразования сущностей базы во внутренние сущности приложения понадобится пакет AutoMapper.
    - так же добавить класс-репозиторий для работы с БД "HomeDeviceRepository"